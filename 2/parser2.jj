/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\parser2.jj */
/*@egen*/options
{
  LOOKAHEAD=1;
             
               
                         
}
PARSER_BEGIN(JavaParser)
import java.io.*;

public class JavaParser/*@bgen(jjtree)*/implements JavaParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTJavaParserState jjtree = new JJTJavaParserState();

/*@egen*/
      
    public static void main(String[] args) throws Exception {
      //StringReader in=new StringReader();
      if (args.length < 1){
        System.err.println("Not enough argument");
        System.exit(1);
      }
      JavaParser javaParser=new JavaParser(new FileInputStream(new File(args[0])));
      try {
        ASTStart n = javaParser.Start();
        JavaParserVisitor v = new JavaParserDumpVisitor();
        n.jjtAccept(v, null);
        System.out.println("Thank you.");
      } 
      catch (Exception e) {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        e.printStackTrace();
      }
    }
}

PARSER_END(JavaParser)

SKIP: { " " | "\t" |"\n" |"\r"}


//RESERVED WORDS
TOKEN : {
 <NOT: "not">
|  <IF: "if">
|  <END: "end">
|  <SUB: "sub">
|  <LET: "let">
|  <CALL: "call">
|  <THEN: "then">
|  <CASE: "case">
|  <ELSE: "else">
|  <INPUT: "input">
|  <SELECT: "select">
|  <STATIC: "static">
| <CLASS: "class">
| <PUBLIC: "public">
| <VOID: "void">
| <MAIN: "main">
| <EXTENDS: "extends">
| <PRINT: "System.out.println">
| <WHILE: "while">
| <NEW : "new">
| <THIS: "this">
| <RETURN: "return">
}

//TYPE
TOKEN: {
  <TYPE : ("int" | "boolean")(<OPEN_BRACKET> <CLOSE_BRACKET>)?>
}

TOKEN : {
 <STRING: "String">
}

//IDENTIFIER TOKEN
TOKEN : {
 <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*(["$"])?>
|  <#LETTER: (["a"-"z","A"-"Z"])>
}


TOKEN: { <PLUS: "+">  }
TOKEN: { <MINUS: "-">  }
TOKEN: { <TIMES: "*">  }
TOKEN: { <DIVIDE: "/">  }
TOKEN: { <EQUALS: "=">  }
TOKEN : { < OPEN_PAR : "(" > }
TOKEN : { < CLOSE_PAR : ")" > }
TOKEN : { < OPEN_BRACE : "{" > }
TOKEN : { < CLOSE_BRACE : "}" > }
TOKEN : { < OPEN_BRACKET : "[" > }
TOKEN : { < CLOSE_BRACKET : "]" > }
TOKEN : { < SEMI_COLON : ";" > }
TOKEN : { < COMMA : "," > }
TOKEN : {<OPERATOR : <PLUS> | <MINUS> | <TIMES> | <DIVIDE>>}

//STATIC TOKENS
TOKEN : {
 <#DIGIT: ["0"-"9"]> 
 | <INTEGER_CONSTANT: (<DIGIT>)+>
 |  < FLOATING_POINT_LITERAL:
        (<DIGIT>)+ "." (<DIGIT>)*(["f","F","d","D"])?
      | "." (<DIGIT>)+ (["f","F","d","D"])?
      | (<DIGIT>)+  (["f","F","d","D"])?
      | (<DIGIT>)+ ["f","F","d","D"]
  >
|  < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
|  <LOGIC_CONSTANT: "true" | "false" | "-1">
|  <STRING_CONSTANT: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ( ["\n","\r"] | "\r\n")))* "\"">
}

ASTStart Start()       :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
try {
/*@egen*/
Program()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Program():
{}
{
  MainClass() 
  (ClassDecl())*
  <EOF>
}

void MainClass()      :
{/*@bgen(jjtree) main */
  ASTmain jjtn000 = new ASTmain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;  
}
{/*@bgen(jjtree) main */
  try {
/*@egen*/
  <CLASS>  t = <IDENTIFIER> 
  {jjtn000.setName(t.image);}
  <OPEN_BRACE>

  <PUBLIC> <STATIC> <VOID> <MAIN> <OPEN_PAR> 
  [<STRING> <OPEN_BRACKET> <CLOSE_BRACKET> <IDENTIFIER> {jjtn000.setHasArgs(true);}] 
  <CLOSE_PAR> 
  <OPEN_BRACE>
    Statement()
  <CLOSE_BRACE>
  <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ClassDecl()       :
{/*@bgen(jjtree) Class */
  ASTClass jjtn000 = new ASTClass(JJTCLASS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Class */
  try {
/*@egen*/
  <CLASS> t = <IDENTIFIER>{jjtn000.setName(t.image); }
  [<EXTENDS> <IDENTIFIER>]
  <OPEN_BRACE>
    (VarDecl())*
    (MethodDecl())*
  <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VarDecl()      :
{/*@bgen(jjtree) type */
  ASTtype jjtn000 = new ASTtype(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) type */
  try {
/*@egen*/
  t = <TYPE> {jjtn000.setType(t.image);} t = <IDENTIFIER> {jjtn000.setName(t.image);} <SEMI_COLON>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void FormalList()      :
{/*@bgen(jjtree) args */
  ASTargs jjtn000 = new ASTargs(JJTARGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) args */
  try {
/*@egen*/
  t = <TYPE> {jjtn000.addType(t.image);} t = <IDENTIFIER>{{jjtn000.addName(t.image);}} 
  (<COMMA> t = <TYPE> {jjtn000.addType(t.image);} t = <IDENTIFIER>{jjtn000.addName(t.image);})*/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MethodDecl()        :
{/*@bgen(jjtree) method */
  ASTmethod jjtn000 = new ASTmethod(JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) method */
  try {
/*@egen*/
  <PUBLIC> <TYPE> t = <IDENTIFIER>{jjtn000.setMethodName(t.image);}
  <OPEN_PAR> (FormalList())* <CLOSE_PAR>
  <OPEN_BRACE> (Statement())* <RETURN> t = <IDENTIFIER> <SEMI_COLON> {jjtn000.setReturnName(t.image);} <CLOSE_BRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Statement():
{
}
{
  <IDENTIFIER> (<OPEN_BRACKET> Expression() <CLOSE_BRACKET>)? <EQUALS> Expression() <SEMI_COLON>
  | <PRINT> <OPEN_PAR> Expression() <CLOSE_PAR> <SEMI_COLON> 
  | IfStatement()
  | WhileStatement()
  | StatementBr()
  | VarDecl()
}

void StatementBr():
{}
{
  <OPEN_BRACE> (Statement())* <CLOSE_BRACE>
}

void IfStatement()        :
{/*@bgen(jjtree) ifstmt */
  ASTifstmt jjtn000 = new ASTifstmt(JJTIFSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifstmt */
  try {
/*@egen*/
  <IF> <OPEN_PAR> Expression() <CLOSE_PAR> [<ELSE> Statement()]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof NumberFormatException) {
      throw (NumberFormatException)jjte000;
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void WhileStatement()           :
{/*@bgen(jjtree) whilestmt */
  ASTwhilestmt jjtn000 = new ASTwhilestmt(JJTWHILESTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) whilestmt */
  try {
/*@egen*/
  <WHILE> <OPEN_PAR> Expression() <CLOSE_PAR> Statement()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof NumberFormatException) {
      throw (NumberFormatException)jjte000;
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression() throws NumberFormatException     :
{/*@bgen(jjtree) exp */
  ASTexp jjtn000 = new ASTexp(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) exp */
  try {
/*@egen*/
  <OPEN_PAR> Expression() <CLOSE_PAR>
  | "!" Expression()
  | t = <LOGIC_CONSTANT>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.addName(t.image);}
  | t = <IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.addName(t.image);}
  | t = <THIS>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.addName(t.image);}
  | <NEW> (<TYPE> <OPEN_BRACKET> Expression() <CLOSE_BRACKET> | <IDENTIFIER> <OPEN_PAR> <CLOSE_PAR>)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof NumberFormatException) {
      throw (NumberFormatException)jjte000;
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Primary() throws NumberFormatException :
{
  Token t ;
  double d;
  }
  {
  t=<INTEGER_CONSTANT>
  |
  t = <LOGIC_CONSTANT>
  |
  <OPEN_PAR> Expression() <CLOSE_PAR>
  |
  <MINUS> Primary()
}

void Term() throws NumberFormatException :
{
  }
  {
  Primary()
  (
  <TIMES>
  Primary()
  |
  <DIVIDE>
  Primary()
  )*
}